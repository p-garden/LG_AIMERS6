# -*- coding: utf-8 -*-
"""preprocess_mljar2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HKZrMcQD_ogj8xPwE7PR-rEbKlaXZ9Bu
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/AIMERS/

pip install mljar-supervised

from supervised.automl import AutoML
import pandas as pd
from sklearn.model_selection import train_test_split
import category_encoders as ce
import joblib
from sklearn.metrics import roc_auc_score
# ğŸ“Œ ë°ì´í„° ë¡œë“œ
train = pd.read_csv("data/train.csv")
test = pd.read_csv("data/test.csv")

# ğŸ”¹ ID ì»¬ëŸ¼ ì €ì¥
test_id = test["ID"]

# ğŸ”¹ ë¶ˆí•„ìš”í•œ ì—´ ì œê±° (IDëŠ” í•™ìŠµì— í•„ìš” ì—†ìŒ)
train = train.drop(columns=["ID"])
test = test.drop(columns=["ID"])

"""## ì§ì ‘ ì „ì²˜ë¦¬
AutoMLì€ ì¼ê´„ì ìœ¼ë¡œ ì¹¼ëŸ¼ë“¤ì—ëŒ€í•´ ì „ì²˜ë¦¬ë¥¼ ì§„í–‰í•˜ë¯€ë¡œ ì¹¼ëŸ¼ íŠ¹ì„±ì— ë§ì¶° ì§ì ‘ ì „ì²˜ë¦¬ ì§„í–‰  
ê²°ì¸¡ì¹˜ ì²˜ë¦¬, ë²”ì£¼í˜• ë³€ìˆ˜ ì²˜ë¦¬, í‘œì¤€í™” ë¡œ ë‚˜ëˆ„ì–´ ì§„í–‰

### ê²°ì¸¡ì¹˜ ê´€ë ¨ ì²˜ë¦¬
"""

for df in [train, test]:

    # 2ï¸âƒ£ ë³¸ì¸ ë‚œì ì‚¬ìš© ì—¬ë¶€ (ë‚œì ì±„ì·¨ ê²½ê³¼ì¼ì´ ì¡´ì¬í•˜ë©´ 1)
    df["ë³¸ì¸ ë‚œì ì‚¬ìš© ì—¬ë¶€"] = df["ë‚œì ì±„ì·¨ ê²½ê³¼ì¼"].notnull().astype(int)

    # 3ï¸âƒ£ ë™ê²° ë‚œì ì‚¬ìš© ì—¬ë¶€ (í•´ë™ ë‚œì ìˆ˜ê°€ 1ê°œ ì´ìƒì´ë©´ 1)
    df["ë™ê²° ë‚œì ì‚¬ìš© ì—¬ë¶€"] = (df["í•´ë™ ë‚œì ìˆ˜"] >= 1).astype(int)

    # 4ï¸âƒ£ ê¸°ì¦ ë‚œì ì‚¬ìš© ì—¬ë¶€ (ë‚œì ì¶œì²˜ê°€ 'ê¸°ì¦ ì œê³µ'ì´ë©´ 1)
    df["ê¸°ì¦ ë‚œì ì‚¬ìš© ì—¬ë¶€"] = (df["ë‚œì ì¶œì²˜"] == "ê¸°ì¦ ì œê³µ").astype(int)

    # 5ï¸âƒ£ ë™ê²° ë°°ì•„ ì‚¬ìš© ì—¬ë¶€ (ë™ê²° ë°°ì•„ ì‚¬ìš© ì—¬ë¶€ê°€ 1ì´ë©´ 1)
    df["ë™ê²° ë°°ì•„ ì‚¬ìš© ì—¬ë¶€"] = (df["ë™ê²° ë°°ì•„ ì‚¬ìš© ì—¬ë¶€"] == 1).astype(int)

    # 6ï¸âƒ£ ê¸°ì¦ ë°°ì•„ ì‚¬ìš© ì—¬ë¶€ (ê¸°ì¦ ë°°ì•„ ì‚¬ìš© ì—¬ë¶€ê°€ 1ì´ë©´ 1)
    df["ê¸°ì¦ ë°°ì•„ ì‚¬ìš© ì—¬ë¶€"] = (df["ê¸°ì¦ ë°°ì•„ ì‚¬ìš© ì—¬ë¶€"] == 1).astype(int)

for df in [train, test]:
    df["ìœ ì „ ê²€ì‚¬ ì—¬ë¶€"] = '0'  # ê¸°ë³¸ê°’ 0 (IVFê°€ ì•„ë‹Œ ê²½ìš°)

    # IVF ì‹œìˆ  ì—¬ë¶€ í•„í„°
    ivf_mask = df["ì‹œìˆ  ìœ í˜•"] == "IVF"

    # PGS ë˜ëŠ” PGD ì‹œìˆ  ì—¬ë¶€ í™•ì¸
    genetic_test_mask = df["PGS ì‹œìˆ  ì—¬ë¶€"].notnull() | df["PGD ì‹œìˆ  ì—¬ë¶€"].notnull()

    # IVFì´ë©´ì„œ PGS ë˜ëŠ” PGD ì¤‘ í•˜ë‚˜ë¼ë„ ìˆìœ¼ë©´ 1
    df.loc[ivf_mask & genetic_test_mask, "ìœ ì „ ê²€ì‚¬ ì—¬ë¶€"] = '1'

    # IVFì´ë©´ì„œ ë‘˜ ë‹¤ ì—†ëŠ” ê²½ìš° 'Unknown' ì²˜ë¦¬
    df.loc[ivf_mask & ~genetic_test_mask, "ìœ ì „ ê²€ì‚¬ ì—¬ë¶€"] = "Unknown"

for df in [train, test]:
    df["ê³¼ê±° ì„ì‹  ì„±ê³µ ì—¬ë¶€"] = df["ì´ ì„ì‹  íšŸìˆ˜"].map({
        "0íšŒ": 0,  # ì„ì‹  ê²½í—˜ ì—†ìŒ
        "1íšŒ": 1, "2íšŒ": 1, "3íšŒ": 1, "4íšŒ": 1, "5íšŒ": 1, "6íšŒ ì´ìƒ": 1  # ì„ì‹  ê²½í—˜ ìˆìŒ
    }).fillna(0).astype(int)  # ê²°ì¸¡ê°’ì€ 0ìœ¼ë¡œ ì²˜ë¦¬

for df in [train, test]:
    df["ë°°ì•„ ì´ì‹ ê²½ê³¼ì¼"] = df["ë°°ì•„ ì´ì‹ ê²½ê³¼ì¼"].fillna(3)

drop_cols = [
    "ë‚œì í•´ë™ ê²½ê³¼ì¼", "PGS ì‹œìˆ  ì—¬ë¶€", "PGD ì‹œìˆ  ì—¬ë¶€", "ì°©ìƒ ì „ ìœ ì „ ê²€ì‚¬ ì‚¬ìš© ì—¬ë¶€",
    "ì„ì‹  ì‹œë„ ë˜ëŠ” ë§ˆì§€ë§‰ ì„ì‹  ê²½ê³¼ ì—°ìˆ˜", "ë°°ì•„ í•´ë™ ê²½ê³¼ì¼", "ë‚œì ì±„ì·¨ ê²½ê³¼ì¼", "ë‚œì í˜¼í•© ê²½ê³¼ì¼"
]

train = train.drop(columns=drop_cols)
test = test.drop(columns=drop_cols)
print(train.columns)
print(test.columns)

"""### ë²”ì£¼í˜• ë³€ìˆ˜ ê´€ë ¨ ì²˜ë¦¬"""

# ë²”ì£¼í˜• ë³€ìˆ˜ í™•ì¸
categorical_cols_train = train.select_dtypes(include=["object"]).columns.tolist()
categorical_cols_train

import category_encoders as ce
import joblib

target_encoder = ce.TargetEncoder(cols=["ì‹œìˆ  ë‹¹ì‹œ ë‚˜ì´"])
train["ì‹œìˆ  ë‹¹ì‹œ ë‚˜ì´"] = target_encoder.fit_transform(train["ì‹œìˆ  ë‹¹ì‹œ ë‚˜ì´"], train["ì„ì‹  ì„±ê³µ ì—¬ë¶€"])
test["ì‹œìˆ  ë‹¹ì‹œ ë‚˜ì´"] = target_encoder.transform(test["ì‹œìˆ  ë‹¹ì‹œ ë‚˜ì´"])

from sklearn.preprocessing import LabelEncoder

# Label Encoding ì ìš©
label_encoder = LabelEncoder()
train["ì‹œìˆ  ìœ í˜•"] = label_encoder.fit_transform(train["ì‹œìˆ  ìœ í˜•"])
test["ì‹œìˆ  ìœ í˜•"] = label_encoder.transform(test["ì‹œìˆ  ìœ í˜•"])

train["íŠ¹ì • ì‹œìˆ  ìœ í˜•"].value_counts()

# íƒ€ê¹ƒ ì¸ì½”ë”© ì ìš©í•  ë²”ì£¼í˜• ë³€ìˆ˜ ì„ íƒ
categorical_cols = ["íŠ¹ì • ì‹œìˆ  ìœ í˜•"]

# íƒ€ê¹ƒ ì¸ì½”ë”© ìˆ˜í–‰
target_encoder = ce.TargetEncoder(cols=categorical_cols, smoothing=0.3)
train["íŠ¹ì • ì‹œìˆ  ìœ í˜•"] = target_encoder.fit_transform(train["íŠ¹ì • ì‹œìˆ  ìœ í˜•"],  train["ì„ì‹  ì„±ê³µ ì—¬ë¶€"])
test["íŠ¹ì • ì‹œìˆ  ìœ í˜•"] = target_encoder.transform(test["íŠ¹ì • ì‹œìˆ  ìœ í˜•"])



train['ë°°ë€ ìœ ë„ ìœ í˜•'].value_counts()

train["ë°°ë€ ìœ ë„ ì—¬ë¶€"] = train["ë°°ë€ ìœ ë„ ìœ í˜•"].apply(lambda x: 1 if x in ["ì„¸íŠ¸ë¡œíƒ€ì´ë“œ (ì–µì œì œ)", "ìƒì‹ì„  ìê·¹ í˜¸ë¥´ëª¬"] else 0)
test["ë°°ë€ ìœ ë„ ì—¬ë¶€"] = test["ë°°ë€ ìœ ë„ ìœ í˜•"].apply(lambda x: 1 if x in ["ì„¸íŠ¸ë¡œíƒ€ì´ë“œ (ì–µì œì œ)", "ìƒì‹ì„  ìê·¹ í˜¸ë¥´ëª¬"] else 0)

# ì›ë˜ ë³€ìˆ˜ ì œê±°
train = train.drop(columns=["ë°°ë€ ìœ ë„ ìœ í˜•"])
test = test.drop(columns=["ë°°ë€ ìœ ë„ ìœ í˜•"])

train["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "].value_counts()

import category_encoders as ce

# íƒ€ê¹ƒ ì¸ì½”ë”© ì ìš©
target_encoder = ce.TargetEncoder(cols=["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "], smoothing=0.3)
train["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "] = target_encoder.fit_transform(train["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "],  train["ì„ì‹  ì„±ê³µ ì—¬ë¶€"])
test["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "] = target_encoder.transform(test["ë°°ì•„ ìƒì„± ì£¼ìš” ì´ìœ "])

# "íšŸìˆ˜" ì»¬ëŸ¼ë“¤ ë¦¬ìŠ¤íŠ¸
count_cols = [
    "ì´ ì‹œìˆ  íšŸìˆ˜", "í´ë¦¬ë‹‰ ë‚´ ì´ ì‹œìˆ  íšŸìˆ˜", "IVF ì‹œìˆ  íšŸìˆ˜", "DI ì‹œìˆ  íšŸìˆ˜",
    "ì´ ì„ì‹  íšŸìˆ˜", "IVF ì„ì‹  íšŸìˆ˜", "DI ì„ì‹  íšŸìˆ˜",
    "ì´ ì¶œì‚° íšŸìˆ˜", "IVF ì¶œì‚° íšŸìˆ˜", "DI ì¶œì‚° íšŸìˆ˜"
]

# "íšŸìˆ˜" ë°ì´í„°ë¥¼ ìˆ«ìë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
def convert_count(value):
    if isinstance(value, str):  # ë¬¸ìì—´ì´ë©´ ì²˜ë¦¬
        if "ì´ìƒ" in value:  # "6íšŒ ì´ìƒ" ê°™ì€ ê²½ìš°
            return int(value.split("íšŒ")[0]) + 1  # 6íšŒ ì´ìƒ â†’ 7ë¡œ ë³€í™˜
        return int(value.replace("íšŒ", ""))  # '3íšŒ' â†’ 3ìœ¼ë¡œ ë³€í™˜
    return value  # ì´ë¯¸ ìˆ«ìì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜

# ë³€í™˜ ì ìš©
for col in count_cols:
    train[col] = train[col].apply(convert_count)
    test[col] = test[col].apply(convert_count)

print("âœ… 'íšŸìˆ˜' ì¹¼ëŸ¼ ìˆ«ì ë³€í™˜ ì™„ë£Œ!")

train["ì •ì ì¶œì²˜"].value_counts()

# ì›-í•« ì¸ì½”ë”© ì ìš©
train = pd.get_dummies(train, columns=["ë‚œì ì¶œì²˜", "ì •ì ì¶œì²˜"], dtype=int)
test = pd.get_dummies(test, columns=["ë‚œì ì¶œì²˜", "ì •ì ì¶œì²˜"], dtype=int)

print("âœ… 'ë‚œì ì¶œì²˜', 'ì •ì ì¶œì²˜' ì›-í•« ì¸ì½”ë”© ì™„ë£Œ!")

train["ì •ì ê¸°ì¦ì ë‚˜ì´"].value_counts()

import category_encoders as ce

# íƒ€ê¹ƒ ì¸ì½”ë”© ìˆ˜í–‰
target_encoder = ce.TargetEncoder(cols=["ë‚œì ê¸°ì¦ì ë‚˜ì´", "ì •ì ê¸°ì¦ì ë‚˜ì´"], smoothing=0.3)
train[["ë‚œì ê¸°ì¦ì ë‚˜ì´", "ì •ì ê¸°ì¦ì ë‚˜ì´"]] = target_encoder.fit_transform(train[["ë‚œì ê¸°ì¦ì ë‚˜ì´", "ì •ì ê¸°ì¦ì ë‚˜ì´"]], train["ì„ì‹  ì„±ê³µ ì—¬ë¶€"])
test[["ë‚œì ê¸°ì¦ì ë‚˜ì´", "ì •ì ê¸°ì¦ì ë‚˜ì´"]] = target_encoder.transform(test[["ë‚œì ê¸°ì¦ì ë‚˜ì´", "ì •ì ê¸°ì¦ì ë‚˜ì´"]])

print("âœ… 'ë‚œì ê¸°ì¦ì ë‚˜ì´', 'ì •ì ê¸°ì¦ì ë‚˜ì´' íƒ€ê¹ƒ ì¸ì½”ë”© ì™„ë£Œ!")

train["ìœ ì „ ê²€ì‚¬ ì—¬ë¶€"].value_counts()

# 'ìœ ì „ ê²€ì‚¬ ì—¬ë¶€' ê°’ë³„ ì„ì‹  ì„±ê³µ ì—¬ë¶€ í‰ê·  ê³„ì‚°
probabilities = train.groupby("ìœ ì „ ê²€ì‚¬ ì—¬ë¶€")["ì„ì‹  ì„±ê³µ ì—¬ë¶€"].mean()

# ê²°ê³¼ ì¶œë ¥
probabilities

# ìœ ì „ ê²€ì‚¬ ì—¬ë¶€ ì¹¼ëŸ¼ì„ íƒ€ê¹ƒ ì¸ì½”ë”© ì ìš©
target_encoder = ce.TargetEncoder(cols=['ìœ ì „ ê²€ì‚¬ ì—¬ë¶€'], smoothing=0.3)

# í•™ìŠµ ë°ì´í„°ì— ëŒ€í•´ íƒ€ê¹ƒ ì¸ì½”ë”© ì ìš©
train['ìœ ì „ ê²€ì‚¬ ì—¬ë¶€'] = target_encoder.fit_transform(train['ìœ ì „ ê²€ì‚¬ ì—¬ë¶€'], train['ì„ì‹  ì„±ê³µ ì—¬ë¶€'])

# í…ŒìŠ¤íŠ¸ ë°ì´í„°ì—ë„ ë™ì¼í•œ ë³€í™˜ ì ìš©
test['ìœ ì „ ê²€ì‚¬ ì—¬ë¶€'] = target_encoder.transform(test['ìœ ì „ ê²€ì‚¬ ì—¬ë¶€'])

drop_cols = ['ì‹œìˆ  ì‹œê¸° ì½”ë“œ']
train = train.drop(columns=drop_cols)
test = test.drop(columns=drop_cols)

# ë²”ì£¼í˜• ë³€ìˆ˜ í™•ì¸
categorical_cols_test = test.select_dtypes(include=["object"]).columns.tolist()
categorical_cols_test

# ë‚¨ì„± ë¶ˆì„ ì›ì¸ì˜ ê°’ ë¶„í¬
print(train["ë‚¨ì„± ì£¼ ë¶ˆì„ ì›ì¸"].value_counts())

# ë‚¨ì„± ë¶ˆì„ ì›ì¸ ê°’ë³„ ì„ì‹  ì„±ê³µë¥  í™•ì¸
success_rate = train.groupby("ë‚¨ì„± ì£¼ ë¶ˆì„ ì›ì¸")["ì„ì‹  ì„±ê³µ ì—¬ë¶€"].mean()
print(success_rate)

"""### í‘œì¤€í™”"""

# ìˆ«ìí˜• ë³€ìˆ˜ ì„ íƒ
numeric_cols = train.select_dtypes(include=['int64', 'float64']).columns

# ê° ìˆ«ìí˜• ì†ì„±ë“¤ì˜ ìµœì†Œê°’, ìµœëŒ€ê°’ ë²”ìœ„ í™•ì¸
range_train = train[numeric_cols].agg(['min', 'max']).T
range_train.columns = ['Min', 'Max']

# ëª¨ë“  í–‰ì„ ì¶œë ¥í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)

# ìµœì†Œê°’ê³¼ ìµœëŒ€ê°’ ì¶œë ¥
print(range_train)

# 1ì„ ì´ˆê³¼í•˜ëŠ” ìµœëŒ€ê°’ì„ ê°€ì§„ ì—´ë“¤ ì°¾ê¸°
cols_to_scale = range_train[range_train["Max"] > 1].index.tolist()
print(f"âœ… í‘œì¤€í™” ì ìš© ëŒ€ìƒ ì¹¼ëŸ¼: {cols_to_scale}")

from sklearn.preprocessing import StandardScaler

# í‘œì¤€í™” ì ìš©
scaler = StandardScaler()
train[cols_to_scale] = scaler.fit_transform(train[cols_to_scale])
test[cols_to_scale] = scaler.transform(test[cols_to_scale])

print("âœ… í‘œì¤€í™” ì ìš© ì™„ë£Œ!")

train.describe()

test.info()



"""## AutoML ì ìš©"""

# ğŸ”¹ íŠ¹ì§•(X)ì™€ íƒ€ê²Ÿ(y) ë¶„ë¦¬
X_train = train.drop(columns=["ì„ì‹  ì„±ê³µ ì—¬ë¶€"])
y_train = train["ì„ì‹  ì„±ê³µ ì—¬ë¶€"]
X_test = test.copy()

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.2, random_state=42, stratify=y_train)

automl = AutoML(
    mode="Compete",
    total_time_limit=7200,
    eval_metric="auc",  # í‰ê°€ ê¸°ì¤€ì„ ROC-AUCë¡œ ì„¤ì •
    golden_features=True,  # ì¤‘ìš”í•œ í”¼ì²˜ ìƒì„±
    kmeans_features=True,  # K-means ê¸°ë°˜ í”¼ì²˜ ìƒì„±
    mix_encoding=True,  # ë‹¤ì–‘í•œ ì¸ì½”ë”© ì ìš©
    algorithms=["CatBoost", "LightGBM", "Xgboost"],  # ì„±ëŠ¥ì´ ë‚®ì€ ëª¨ë¸ ì œì™¸

)

automl.fit(X_train, y_train)

# âœ… ê²€ì¦ (Validation Setìœ¼ë¡œ ì„±ëŠ¥ í™•ì¸)
val_preds = automl.predict_proba(X_val)[:, 1]  # í™•ë¥ ê°’ ì˜ˆì¸¡
val_auc = roc_auc_score(y_val, val_preds)  # ROC-AUC ê³„ì‚°

print(f"\nğŸ¯ ê²€ì¦ ë°ì´í„° ROC-AUC: {val_auc:.4f}")

# ğŸ“Œ ì˜ˆì¸¡ ìˆ˜í–‰
preds = automl.predict_proba(X_test)[:, 1]

# ğŸ“Œ ê²°ê³¼ ì €ì¥
submission = pd.DataFrame({"ID": test_id, "probability": preds})
submission.to_csv("AutoML_9/submission_mljar.csv", index=False, encoding="utf-8-sig")

print("\nâœ… [ê²°ê³¼ ì €ì¥ ì™„ë£Œ] íŒŒì¼: submission_mljar.csv")

from google.colab import files
files.download("submission_mljar2.csv")

